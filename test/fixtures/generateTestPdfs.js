/**
 * Generate test PDF files with tables for integration testing
 *
 * Run with: node test/fixtures/generateTestPdfs.js
 *
 * Note: PDFs generated by pdfkit v0.17.2 may have compatibility issues
 * with the older version of pdf.js used by pdf-parse v1.1.1.
 * We set autoFirstPage and bufferPages to false to minimize issues.
 */

import PDFDocument from 'pdfkit';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Logger for consistent output
import { createTestLogger } from '../helpers/testLogger.js';
const log = createTestLogger('fixtures:pdf');

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Generate a simple PDF with a bordered 3x3 table
 */
async function generateSimpleTablePdf() {
  return new Promise((resolve, reject) => {
    // Use PDF 1.4 compatible settings for better pdf-parse compatibility
    const doc = new PDFDocument({
      size: 'A4',
      margin: 50,
      pdfVersion: '1.4',
      compress: false, // Disable compression for better compatibility
    });
    const outputPath = path.join(__dirname, 'simple-table.pdf');
    const stream = fs.createWriteStream(outputPath);

    stream.on('finish', () => {
      log.info('Created test PDF', { path: outputPath });
      resolve();
    });
    stream.on('error', reject);

    doc.pipe(stream);

    // Title
    doc.fontSize(16).font('Helvetica-Bold').text('Simple Table Test Document', { align: 'center' });
    doc.moveDown(2);

    // Draw a 3x3 table with borders
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidth = 150;
    const rowHeight = 30;
    const cols = 3;
    const rows = 3;

    // Table data
    const data = [
      ['Name', 'Age', 'City'],
      ['John Doe', '30', 'New York'],
      ['Jane Smith', '25', 'London'],
    ];

    // Draw table cells with borders
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const x = tableLeft + col * colWidth;
        const y = tableTop + row * rowHeight;

        // Draw cell border
        doc.rect(x, y, colWidth, rowHeight).stroke();

        // Draw cell content
        const cellContent = data[row][col];
        const isHeader = row === 0;
        const isNumeric = col === 1 && row > 0; // Age column

        doc.fontSize(10)
          .font(isHeader ? 'Helvetica-Bold' : 'Helvetica')
          .text(cellContent, x + 5, y + 10, {
            width: colWidth - 10,
            align: isNumeric ? 'right' : 'left',
          });
      }
    }

    // Add some text after the table
    doc.y = tableTop + rows * rowHeight + 20;
    doc.fontSize(10).font('Helvetica')
      .text('This is a test document containing a simple bordered table.');

    doc.end();
  });
}

/**
 * Generate a PDF with text only (no tables)
 */
async function generateTextOnlyPdf() {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({
      size: 'A4',
      margin: 50,
      pdfVersion: '1.4',
      compress: false,
    });
    const outputPath = path.join(__dirname, 'text-only.pdf');
    const stream = fs.createWriteStream(outputPath);

    stream.on('finish', () => {
      log.info('Created test PDF', { path: outputPath });
      resolve();
    });
    stream.on('error', reject);

    doc.pipe(stream);

    // Title
    doc.fontSize(16).font('Helvetica-Bold').text('Text Only Document', { align: 'center' });
    doc.moveDown(2);

    // Paragraphs of text
    doc.fontSize(12).font('Helvetica')
      .text('This document contains only regular text paragraphs. There are no tables present in this document.')
      .moveDown()
      .text('The purpose of this file is to test that the table detection algorithm correctly identifies when no tables are present and falls back to standard text extraction.')
      .moveDown()
      .text('Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.');

    doc.end();
  });
}

/**
 * Generate a multi-page PDF with tables on different pages
 */
async function generateMultiPageTablePdf() {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({
      size: 'A4',
      margin: 50,
      pdfVersion: '1.4',
      compress: false,
    });
    const outputPath = path.join(__dirname, 'multi-page-tables.pdf');
    const stream = fs.createWriteStream(outputPath);

    stream.on('finish', () => {
      log.info('Created test PDF', { path: outputPath });
      resolve();
    });
    stream.on('error', reject);

    doc.pipe(stream);

    // Page 1: First table
    doc.fontSize(16).font('Helvetica-Bold').text('Page 1: Products Table', { align: 'center' });
    doc.moveDown(2);

    const table1Data = [
      ['Product', 'Price', 'Stock'],
      ['Widget A', '$19.99', '100'],
      ['Widget B', '$29.99', '50'],
    ];
    drawTable(doc, table1Data, 50, doc.y, 150, 30);

    // Page 2: Second table
    doc.addPage();
    doc.fontSize(16).font('Helvetica-Bold').text('Page 2: Employees Table', { align: 'center' });
    doc.moveDown(2);

    const table2Data = [
      ['Name', 'Department', 'Salary'],
      ['Alice Johnson', 'Engineering', '$85,000'],
      ['Bob Williams', 'Marketing', '$65,000'],
    ];
    drawTable(doc, table2Data, 50, doc.y, 150, 30);

    doc.end();
  });
}

/**
 * Generate a PDF with a table containing special characters
 */
async function generateSpecialCharsPdf() {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({
      size: 'A4',
      margin: 50,
      pdfVersion: '1.4',
      compress: false,
    });
    const outputPath = path.join(__dirname, 'special-chars-table.pdf');
    const stream = fs.createWriteStream(outputPath);

    stream.on('finish', () => {
      log.info('Created test PDF', { path: outputPath });
      resolve();
    });
    stream.on('error', reject);

    doc.pipe(stream);

    doc.fontSize(16).font('Helvetica-Bold').text('Table with Special Characters', { align: 'center' });
    doc.moveDown(2);

    // Table with pipe characters and other special chars
    const data = [
      ['File Path', 'Size'],
      ['C:\\Users\\Documents', '1.5 MB'],
      ['data.csv', '500 KB'],
    ];
    drawTable(doc, data, 50, doc.y, 200, 30);

    doc.end();
  });
}

/**
 * Helper function to draw a table
 */
function drawTable(doc, data, left, top, colWidth, rowHeight) {
  const rows = data.length;
  const cols = data[0].length;

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const x = left + col * colWidth;
      const y = top + row * rowHeight;

      // Draw cell border
      doc.rect(x, y, colWidth, rowHeight).stroke();

      // Draw cell content
      const cellContent = data[row][col];
      const isHeader = row === 0;

      doc.fontSize(10)
        .font(isHeader ? 'Helvetica-Bold' : 'Helvetica')
        .text(cellContent, x + 5, y + 10, {
          width: colWidth - 10,
          align: 'left',
        });
    }
  }

  // Move doc.y past the table
  doc.y = top + rows * rowHeight + 10;
}

// Generate all test PDFs
async function main() {
  log.info('Generating test PDF fixtures');
  await generateSimpleTablePdf();
  await generateTextOnlyPdf();
  await generateMultiPageTablePdf();
  await generateSpecialCharsPdf();
  log.info('PDF fixture generation complete');
}

main().catch(err => {
  log.error('Error generating PDFs', { error: err.message });
  process.exit(1);
});
